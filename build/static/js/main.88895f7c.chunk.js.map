{"version":3,"sources":["logo.svg","bonnie.jpg","faceapi/readLipsticks.js","faceapi/api.js","components/ImageUploader.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","hexToRgb","hex","replace","m","r","g","b","result","exec","parseInt","compareLipstick","targetColor","selectedLipstick","brand","series","color","id","name","dis","i","Lipsticks","brands","length","brandName","console","log","j","seriesName","k","lipsticks","hexColor","initModel","a","faceapi","recognizeLipstick","canvas","withFaceLandmarks","landmarks","mouthPoint","getMouth","mouthColors","getMouthColor","avgColor","getAvgColor","lipstickColor","canvans","context","getContext","data","getImageData","len","Math","round","ImageUploader","props","state","image","undefined","onImageChange","bind","event","target","files","img","this","setState","URL","createObjectURL","getImage","reader","FileReader","readAsDataURL","onload","e","uploadBase64","Image","src","that","document","createElement","width","height","ctx","drawImage","alt","style","type","onChange","Component","App","React","createRef","lipColor","lipstick","getElementById","drawHTMLImage","current","className","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.88895f7c.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","module.exports = __webpack_public_path__ + \"static/media/bonnie.baeadfc2.jpg\";","import Lipsticks from './lipstick.json'\r\n\r\nfunction hexToRgb(hex) {\r\n    // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\r\n    var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n    hex = hex.replace(shorthandRegex, function(m, r, g, b) {\r\n      return r + r + g + g + b + b;\r\n    });\r\n  \r\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    return result ? {\r\n      r: parseInt(result[1], 16),\r\n      g: parseInt(result[2], 16),\r\n      b: parseInt(result[3], 16)\r\n    } : null;\r\n  }\r\n  \r\n\r\nfunction compareLipstick(targetColor){\r\n    let selectedLipstick = {\r\n        brand: \"\",\r\n        series: \"\",\r\n        color: \"\",\r\n        id: \"\",\r\n        name: \"\",\r\n        dis: 999999999\r\n    }\r\n\r\n    for (let i = 0; i < Lipsticks.brands.length; i++) {\r\n        let brandName = Lipsticks.brands[i].name\r\n        \r\n        console.log(brandName)\r\n        for (let j = 0; j < Lipsticks.brands[i].series.length; j++) {\r\n            let seriesName = Lipsticks.brands[i].series[j].name\r\n            for (let k = 0; k < Lipsticks.brands[i].series[j].lipsticks.length; k++) {\r\n                let hexColor = Lipsticks.brands[i].series[j].lipsticks[k].color\r\n                let color = hexToRgb(hexColor)\r\n                let id = Lipsticks.brands[i].series[j].lipsticks[k].id\r\n                let name = Lipsticks.brands[i].series[j].lipsticks[k].name\r\n                let dis = (targetColor.r - color.r) * (targetColor.r - color.r) + (targetColor.g - color.g) * (targetColor.g - color.g) + (targetColor.b - color.b) * (targetColor.b - color.b)\r\n                console.log(name)\r\n                if(selectedLipstick.dis > dis){\r\n                    selectedLipstick.brand = brandName\r\n                    selectedLipstick.series = seriesName\r\n                    selectedLipstick.color = hexColor\r\n                    selectedLipstick.id = id\r\n                    selectedLipstick.name = name\r\n                    selectedLipstick.dis = dis\r\n                }\r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    return selectedLipstick\r\n}\r\n\r\nexport {hexToRgb, compareLipstick}","import * as faceapi from 'face-api.js';\r\nimport {compareLipstick} from './readLipsticks'\r\n\r\nconst MODEL_URL = '/models'\r\n\r\nasync function initModel() {\r\n    console.log(\"Init Model\")\r\n    try{  \r\n        await faceapi.loadFaceLandmarkTinyModel(MODEL_URL)\r\n        console.log(\"Loaded FaceLandmarkTinyModel\")\r\n        await faceapi.loadTinyFaceDetectorModel(MODEL_URL)\r\n        console.log(\"Loaded TinyFaceDetectorModel\")\r\n        await faceapi.loadSsdMobilenetv1Model(MODEL_URL)\r\n        console.log(\"Loaded SsdMobilenetv1Model\")\r\n    }catch(err){\r\n        console.log(\"Loaded Model Failed\")\r\n    }\r\n}\r\n\r\nasync function recognizeLipstick(canvas){\r\n    // const option = new faceapi.TinyFaceDetectorOptions({512, 0.5})\r\n    const landmarks = await faceapi.detectSingleFace(canvas).withFaceLandmarks(true)\r\n    let mouthPoint = landmarks.landmarks.getMouth()\r\n    let mouthColors = getMouthColor(canvas,mouthPoint)\r\n    let avgColor = getAvgColor(mouthColors)\r\n    let lipstickColor = compareLipstick(avgColor)\r\n    \r\n    // console.log(this.mouthColors)\r\n    // console.log(this.avgColor(this.mouthColors))\r\n    // console.log(compareLipstick(this.avgColor(this.mouthColors)))\r\n    // console.log(lipsticks)\r\n\r\n    return {\r\n        mouthColors: mouthColors,\r\n        avgColor: avgColor,\r\n        lipstickColor: lipstickColor\r\n    }\r\n}\r\n\r\nfunction getMouthColor (canvans, mouthPoint) {\r\n    let context = canvans.getContext(\"2d\")\r\n    let mouthColors = [];\r\n    for (let i =0;i<mouthPoint.length;i++){\r\n        let data = context.getImageData(mouthPoint[i][\"_x\"],mouthPoint[i][\"_y\"],1,1)\r\n        mouthColors[i] = data.data\r\n    }\r\n\r\n    return mouthColors\r\n}\r\n\r\nfunction getAvgColor(mouthColors){\r\n    let r = 0, g = 0, b = 0\r\n    let len = mouthColors.length\r\n    // console.log(mouthColors.length)\r\n    for(let i = 0; i < mouthColors.length; i++){\r\n        // console.log(mouthColors[0])\r\n        r+=mouthColors[i][0]\r\n        g+=mouthColors[i][1]\r\n        b+=mouthColors[i][2]\r\n    }\r\n\r\n    return {\r\n        r: Math.round(r / len),\r\n        g: Math.round(g / len),\r\n        b: Math.round(b / len),\r\n    }\r\n}\r\n\r\nexport {initModel, recognizeLipstick}","import React, { Component } from \"react\";\r\n\r\n/**\r\n * @param {function} getImage - The function will be called with uploaded image as parameter when the component get uploaded image\r\n */\r\n\r\nclass ImageUploader extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      image: undefined\r\n    };\r\n\r\n    this.onImageChange = this.onImageChange.bind(this);\r\n  }\r\n\r\n  onImageChange (event){\r\n    if (event.target.files && event.target.files[0]) {\r\n      let img = event.target.files[0];\r\n      this.setState({\r\n        image: URL.createObjectURL(img)\r\n      });\r\n\r\n      if(this.props.getImage !== undefined){\r\n        let reader = new FileReader()\r\n          reader.readAsDataURL(img)\r\n          reader.onload = async (e)=> {\r\n            let uploadBase64 = new Image();\r\n            uploadBase64.src = e.target.result\r\n            let that = this\r\n            // var uploadedBased64Width = uploadBase64.width\r\n            // var uploadedBased64Height = 800\r\n            // console.log(uploadedBased64Width)\r\n            // console.log(uploadedBased64Height)\r\n            uploadBase64.onload = async function () {\r\n              let canvas = document.createElement(\"canvas\")\r\n              canvas.width = this.width\r\n              canvas.height = this.height\r\n              // console.log(this.width)\r\n              // console.log(this.height)\r\n              let ctx = canvas.getContext(\"2d\")\r\n              let width = this.width\r\n              let height = this.height\r\n              ctx.drawImage(uploadBase64, 0, 0, width, height)\r\n              that.props.getImage(canvas)\r\n              // that.startRecognition(canvas)\r\n            }\r\n          }\r\n\r\n        \r\n      }\r\n    }\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div>\r\n          <div>\r\n            {this.state.image !== undefined? <img src={this.state.image} alt={\"uploaded_img\"} style={{width: \"100%\"}}/> : <div></div>}\r\n            <h1>Select Image</h1>\r\n            <input type=\"file\" name=\"myImage\" onChange={this.onImageChange} />\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\nexport default ImageUploader;","import React from 'react';\nimport {initModel, recognizeLipstick} from './faceapi/api'\nimport ImageUploader from './components/ImageUploader'\nimport logo from './logo.svg';\nimport testImage from './bonnie.jpg'\nimport './App.css';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.canvas = React.createRef();\n    this.mouthColors = []\n    this.lipColor = {}\n\n    this.state = {\n      img: undefined,\n      lipstick: undefined\n    }\n\n    this.getImage = this.getImage.bind(this)\n  }\n\n  drawHTMLImage(canvas,image){\n    const ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(image, 0, 0);\n  }\n\n  async getImage(img){\n    \n\n    // this.drawHTMLImage(this.canvas.current,this.state.img);\n    // let imgEle = new Image()\n    // imgEle.src = img\n    // this.drawHTMLImage(this.canvas.current,imgEle,296,296);\n\n\n    // let imgEle = new Image()\n    // let mycanvas = document.createElement('canvas')\n    // let ctx = mycanvas.getContext('2d')\n    // imgEle.onload = function(){\n    //     ctx.drawImage(imgEle, 0, 0);\n    // };\n    // imgEle.src = img;\n    let lipstick = await recognizeLipstick(img)\n    this.lipColor = lipstick\n    console.log(lipstick)\n    console.log(this.lipColor)\n    this.setState({\n      img: img,\n      lipstick: lipstick.lipstickColor\n    })\n  }\n\n  async componentDidMount() {\n    await initModel()\n    if(this.state.img !== undefined){\n      const testImageHTML = document.getElementById('test')\n      this.drawHTMLImage(this.canvas.current,this.state.img,296,296);\n      this.lipColor = await recognizeLipstick(this.canvas.current)\n      console.log(this.lipColor)\n    }\n    \n  }\n  \n  render() {\n    return (\n      <div className=\"App\">\n        {/* <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            Edit <code>src/App.js</code> and save to reload.\n          </p>\n          <a\n            className=\"App-link\"\n            href=\"https://reactjs.org\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Learn React\n          </a>\n        </header> */}\n        <ImageUploader getImage={this.getImage}/>\n        {/* {this.state.img !== undefined? <img id=\"test\" src={this.state.img} alt=\"test\" /> : <div></div>} */}\n        {/* {this.state.img} */}\n        {/* <canvas ref={this.canvas} width={296} height={296} /> */}\n        {this.state.lipstick !== undefined? <h3 style={{color: this.state.lipstick.color}}>{this.state.lipstick.color + \" \" + this.state.lipstick.brand + \" \" + this.state.lipstick.series + \" \" + this.state.lipstick.name}</h3> : <h3></h3>}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}